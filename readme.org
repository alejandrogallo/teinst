* API
:PROPERTIES:
:header-args:c+++: :noweb yes :eval no
:header-args:lisp+: :eval no :noweb yes
:header-args:c+: :eval no
:header-args:org+: :eval no
:END:

** Scripts                                                         :noexport:

#+name: instantiate-template
#+begin_src shell :var in="" tangle="/tmp/test" lang="c++" :results verbatim drawer
echo "#+begin_src $lang :tangle $tangle"
./tools/field-instantiate.sh templates/$in
echo "#+end_src"
#+end_src

#+RESULTS: instantiate-template
:results:
#+begin_src c++ :tangle /tmp/test
#+end_src
:end:


#+name: instantiate-header
#+begin_src shell :var in="" tangle="/tmp/test" lang="c++" :results verbatim drawer
echo "#+begin_src $lang :tangle $tangle"
tmp=$(mktemp)
cp templates/${in} "${tmp}"
sed -i "s/)[ ]*$/);/g" ${tmp}
./tools/field-instantiate.sh ${tmp}
echo "#+end_src"
#+end_src

#+RESULTS: instantiate-header
:results:
#+begin_src c++ :tangle /tmp/test
#+end_src
:end:


** Prolog
*** C and C++

#+begin_src c++ :tangle teinst.h
#ifndef _TEINST_H_DEFINED
#define _TEINST_H_DEFINED

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

#+end_src

#+begin_src c++ :tangle teinst.cxx
#include <backend/ctf.hpp>
#include <complex>
#include <iostream>
#include <string>
#include <teinst.h>
#include <complex.h>

    extern "C" {

#+end_src

*** Lisp

#+begin_src lisp :tangle cffi.lisp
(in-package :teinst)

(define-foreign-library libteinst (t (:default "libteinst")))
(use-foreign-library libteinst)
#+end_src



** The tensor handle =tensor_h= type

#+begin_src c++ :tangle teinst.h
typedef size_t tensor_h;
#+end_src

*** Lisp

#+begin_src lisp :eval no :tangle cffi.lisp
(defctype tensor-h (:pointer :size))
#+end_src

** World functions

#+begin_src c++ :tangle teinst.h
void global_world_init();
void global_world_free();
#+end_src


#+begin_src c++ :tangle teinst.cxx
static CTF::World *TEINST_GLOBAL_WORLD = nullptr;

void global_world_init() {
  if (TEINST_GLOBAL_WORLD == nullptr) {
    TEINST_GLOBAL_WORLD = new CTF::World();
  }
}

void global_world_free() {
  if (TEINST_GLOBAL_WORLD != nullptr) {
    delete TEINST_GLOBAL_WORLD;
    TEINST_GLOBAL_WORLD = nullptr;
  }
}
#+end_src

#+begin_src lisp :tangle cffi.lisp
(defcfun ("global_world_init" %global-world-init) :void)
(defcfun ("global_world_free" %global-world-free) :void)
#+end_src


** =tensor_init=

*** Implementation

#+name: tensor-init-doc
#+begin_src org
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind @FIELD_NAME@.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension.
#+end_src

#+begin_src c++ :noweb-ref tensor-init-header :tangle templates/tensor_init.h
// <<tensor-init-doc>>
void tensor_init_@FIELD_NAME@(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths)
#+end_src

#+begin_src c++ :tangle templates/tensor_init.cxx 
<<tensor-init-header>> {
  using F = @FIELD_TYPE@;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               ,*TEINST_GLOBAL_WORLD);
  ,*t = reinterpret_cast<tensor_h>(_t);
}
#+end_src

#+begin_src lisp :eval no :tangle templates/tensor_init.lisp 
(defcfun ("tensor_init_@FIELD_NAME@" %tensor-init-@FIELD_NAME@) :void
  "
<<tensor-init-doc>>"
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
#+end_src


*** Instantiation
**** Implementation

#+call: instantiate-template(in="tensor_init.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind s.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_s(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = float;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind d.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_d(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = double;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind c.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_c(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = std::complex<float>;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind z.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_z(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = std::complex<double>;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
#+end_src
:end:

**** Header

#+call: instantiate-header(in="tensor_init.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind s.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_s(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind d.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_d(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind c.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_c(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind z.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_z(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_init.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_init_s" %tensor-init-s) :void
  "
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind s.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension."
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_d" %tensor-init-d) :void
  "
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind d.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension."
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_c" %tensor-init-c) :void
  "
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind c.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension."
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_z" %tensor-init-z) :void
  "
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind z.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension."
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
#+end_src
:end:

** =tensor_lengths=

*** Implementation

#+begin_src c++ :noweb-ref tensor-lengths-header :tangle templates/tensor_lengths.h
void tensor_lengths_@FIELD_NAME@(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths)
#+end_src

#+begin_src c++ :tangle templates/tensor_lengths.cxx 
<<tensor-lengths-header>> {
  using F = @FIELD_TYPE@;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }

#+end_src

#+begin_src lisp :eval no :tangle templates/tensor_lengths.lisp
(defcfun ("tensor_lengths_@FIELD_NAME@" %tensor-lengths-@FIELD_NAME@) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
#+end_src


*** Instantiation
**** Implementation
#+call: instantiate-template(in="tensor_lengths.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
void tensor_lengths_s(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths) {
  using F = float;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }
void tensor_lengths_d(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths) {
  using F = double;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }
void tensor_lengths_c(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths) {
  using F = std::complex<float>;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }
void tensor_lengths_z(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths) {
  using F = std::complex<double>;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }
#+end_src
:end:

**** Header
#+call: instantiate-header(in="tensor_lengths.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
void tensor_lengths_s(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths);
void tensor_lengths_d(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths);
void tensor_lengths_c(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths);
void tensor_lengths_z(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_lengths.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_lengths_s" %tensor-lengths-s) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
(defcfun ("tensor_lengths_d" %tensor-lengths-d) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
(defcfun ("tensor_lengths_c" %tensor-lengths-c) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
(defcfun ("tensor_lengths_z" %tensor-lengths-z) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
#+end_src
:end:

** =tensor_free=

*** Implementation

#+begin_src c++ :noweb-ref tensor-free-header :tangle templates/tensor_free.h
void tensor_free_@FIELD_NAME@(tensor_h t)
#+end_src


#+begin_src c++ :tangle templates/tensor_free.cxx
<<tensor-free-header>> {
  using F = @FIELD_TYPE@;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
#+end_src

#+begin_src lisp :tangle templates/tensor_free.lisp
(defcfun ("tensor_free_@FIELD_NAME@" %tensor-free-@FIELD_NAME@) :void
  (tsr tensor-h))
#+end_src


*** Instantiation
**** Implementation

#+call: instantiate-template(in="tensor_free.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
void tensor_free_s(tensor_h t) {
  using F = float;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_d(tensor_h t) {
  using F = double;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_c(tensor_h t) {
  using F = std::complex<float>;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_z(tensor_h t) {
  using F = std::complex<double>;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
#+end_src
:end:

**** Header

#+call: instantiate-header(in="tensor_free.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
void tensor_free_s(tensor_h t);
void tensor_free_d(tensor_h t);
void tensor_free_c(tensor_h t);
void tensor_free_z(tensor_h t);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_free.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_free_s" %tensor-free-s) :void
  (tsr tensor-h))
(defcfun ("tensor_free_d" %tensor-free-d) :void
  (tsr tensor-h))
(defcfun ("tensor_free_c" %tensor-free-c) :void
  (tsr tensor-h))
(defcfun ("tensor_free_z" %tensor-free-z) :void
  (tsr tensor-h))
#+end_src
:end:

** =tensor_name=

#+begin_src c++ :noweb-ref tensor-name-header
void tensor_name(tensor_h t, char** nameptr)
#+end_src


#+begin_src c++ :tangle teinst.h
<<tensor-name-header>>;
#+end_src

#+begin_src c++ :tangle teinst.cxx
<<tensor-name-header>> {
    const std::string name =
        (reinterpret_cast<CTF::Tensor<double> *>(t))->get_name();
    *nameptr = (char *)malloc(name.size());
    memcpy(*nameptr, name.c_str(), name.size());
}
#+end_src

#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_name" %tensor-name) :void
  (tsr tensor-h)
  (name :pointer))
#+end_src


** =tensor_contract=

*** Implementation

#+begin_src c++ :noweb-ref tensor-contract-header :tangle templates/tensor_contract.h 
void tensor_contract_@FIELD_NAME@(@FIELD_CTYPE@ const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  @FIELD_CTYPE@ const * beta,
                                  char const * idx_C,
                                  tensor_h C)
#+end_src

#+begin_src c++ :tangle templates/tensor_contract.cxx 
<<tensor-contract-header>> {
  using F = @FIELD_TYPE@;
  auto _A = reinterpret_cast<CTF::Tensor<F>*>(A);
  auto _B = reinterpret_cast<CTF::Tensor<F>*>(B);
  auto _C = reinterpret_cast<CTF::Tensor<F>*>(C);
  _C->contract(*alpha,
               ,*_A,
               idx_A,
               ,*_B,
               idx_B,
               *beta,
               idx_C);
 }
#+end_src

#+begin_src lisp :tangle templates/tensor_contract.lisp
(defcfun ("tensor_contract_@FIELD_NAME@" %tensor-contract-@FIELD_NAME@) :void
  (alpha :pointer)
  (A tensor-h)
  (idx_A :string)
  (B tensor-h)
  (idx_B :string)
  (beta :pointer)
  (idx_C :string)
  (C tensor-h))
#+end_src


*** Instantiation

**** Header

#+call: instantiate-header(in="tensor_contract.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
void tensor_contract_s(float const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  float const * beta,
                                  char const * idx_C,
                                  tensor_h C);
void tensor_contract_d(double const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  double const * beta,
                                  char const * idx_C,
                                  tensor_h C);
void tensor_contract_c(_Complex float const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  _Complex float const * beta,
                                  char const * idx_C,
                                  tensor_h C);
void tensor_contract_z(_Complex double const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  _Complex double const * beta,
                                  char const * idx_C,
                                  tensor_h C);
#+end_src
:end:

**** Implementation

#+call: instantiate-template(in="tensor_contract.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
void tensor_contract_s(float const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  float const * beta,
                                  char const * idx_C,
                                  tensor_h C) {
  using F = float;
  auto _A = reinterpret_cast<CTF::Tensor<F>*>(A);
  auto _B = reinterpret_cast<CTF::Tensor<F>*>(B);
  auto _C = reinterpret_cast<CTF::Tensor<F>*>(C);
  _C->contract(*alpha,
               *_A,
               idx_A,
               *_B,
               idx_B,
               *beta,
               idx_C);
 }
void tensor_contract_d(double const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  double const * beta,
                                  char const * idx_C,
                                  tensor_h C) {
  using F = double;
  auto _A = reinterpret_cast<CTF::Tensor<F>*>(A);
  auto _B = reinterpret_cast<CTF::Tensor<F>*>(B);
  auto _C = reinterpret_cast<CTF::Tensor<F>*>(C);
  _C->contract(*alpha,
               *_A,
               idx_A,
               *_B,
               idx_B,
               *beta,
               idx_C);
 }
void tensor_contract_c(_Complex float const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  _Complex float const * beta,
                                  char const * idx_C,
                                  tensor_h C) {
  using F = std::complex<float>;
  auto _A = reinterpret_cast<CTF::Tensor<F>*>(A);
  auto _B = reinterpret_cast<CTF::Tensor<F>*>(B);
  auto _C = reinterpret_cast<CTF::Tensor<F>*>(C);
  _C->contract(*alpha,
               *_A,
               idx_A,
               *_B,
               idx_B,
               *beta,
               idx_C);
 }
void tensor_contract_z(_Complex double const * alpha,
                                  tensor_h const A,
                                  char const * idx_A,
                                  tensor_h const B,
                                  char const * idx_B,
                                  _Complex double const * beta,
                                  char const * idx_C,
                                  tensor_h C) {
  using F = std::complex<double>;
  auto _A = reinterpret_cast<CTF::Tensor<F>*>(A);
  auto _B = reinterpret_cast<CTF::Tensor<F>*>(B);
  auto _C = reinterpret_cast<CTF::Tensor<F>*>(C);
  _C->contract(*alpha,
               *_A,
               idx_A,
               *_B,
               idx_B,
               *beta,
               idx_C);
 }
#+end_src
:end:

**** Lisp
#+call: instantiate-template(in="tensor_contract.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_contract_s" %tensor-contract-s) :void
  (alpha :pointer)
  (A tensor-h)
  (idx_A :string)
  (B tensor-h)
  (idx_B :string)
  (beta :pointer)
  (idx_C :string)
  (C tensor-h))
(defcfun ("tensor_contract_d" %tensor-contract-d) :void
  (alpha :pointer)
  (A tensor-h)
  (idx_A :string)
  (B tensor-h)
  (idx_B :string)
  (beta :pointer)
  (idx_C :string)
  (C tensor-h))
(defcfun ("tensor_contract_c" %tensor-contract-c) :void
  (alpha :pointer)
  (A tensor-h)
  (idx_A :string)
  (B tensor-h)
  (idx_B :string)
  (beta :pointer)
  (idx_C :string)
  (C tensor-h))
(defcfun ("tensor_contract_z" %tensor-contract-z) :void
  (alpha :pointer)
  (A tensor-h)
  (idx_A :string)
  (B tensor-h)
  (idx_B :string)
  (beta :pointer)
  (idx_C :string)
  (C tensor-h))
#+end_src
:end:

** Test
:PROPERTIES:
:header-args:c+: :tangle test.c
:END:

*** Prolog

#+begin_src c
#include <assert.h>
#include <mpi.h>
#include <stdio.h>
#include <teinst.h>

#define LOG(...) if (!rank) printf(__VA_ARGS__);

int main(int argc, char **argv) {
  MPI_Init(&argc, &argv);
  int rank, np;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &np);
  LOG("[31mTEINST TEST[0m (:np %d :rank %d)\n\n", np, rank);
  global_world_init();

  size_t TEST_NUMBER = 0;

#+end_src

*** Simple init

#+begin_src c :tangle templates/simple-init.c 
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_@FIELD_NAME@[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\t- tsr = <%p>\n", (void *)tsr);
  tensor_init_@FIELD_NAME@(&tsr, n, lens);
  LOG("\t- tsr = <%p>\n", (void *)tsr);

  tensor_lengths_@FIELD_NAME@(tsr, n, _lenghts);
  LOG("\t- got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("\t- got name %s for <%p>\n", name, (void *)tsr);

  LOG("\t- Freeing <%p>\n", (void *)tsr);
  tensor_free_@FIELD_NAME@(tsr);

  LOG("\n\n");
}
#+end_src

**** Instantiation

#+call: instantiate-template(in="simple-init.c", tangle="test.c", lang="c")

#+RESULTS:
:results:
#+begin_src c :tangle test.c
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_s[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\t- tsr = <%p>\n", (void *)tsr);
  tensor_init_s(&tsr, n, lens);
  LOG("\t- tsr = <%p>\n", (void *)tsr);

  tensor_lengths_s(tsr, n, _lenghts);
  LOG("\t- got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("\t- got name %s for <%p>\n", name, (void *)tsr);

  LOG("\t- Freeing <%p>\n", (void *)tsr);
  tensor_free_s(tsr);

  LOG("\n\n");
}
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_d[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\t- tsr = <%p>\n", (void *)tsr);
  tensor_init_d(&tsr, n, lens);
  LOG("\t- tsr = <%p>\n", (void *)tsr);

  tensor_lengths_d(tsr, n, _lenghts);
  LOG("\t- got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("\t- got name %s for <%p>\n", name, (void *)tsr);

  LOG("\t- Freeing <%p>\n", (void *)tsr);
  tensor_free_d(tsr);

  LOG("\n\n");
}
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_c[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\t- tsr = <%p>\n", (void *)tsr);
  tensor_init_c(&tsr, n, lens);
  LOG("\t- tsr = <%p>\n", (void *)tsr);

  tensor_lengths_c(tsr, n, _lenghts);
  LOG("\t- got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("\t- got name %s for <%p>\n", name, (void *)tsr);

  LOG("\t- Freeing <%p>\n", (void *)tsr);
  tensor_free_c(tsr);

  LOG("\n\n");
}
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_z[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\t- tsr = <%p>\n", (void *)tsr);
  tensor_init_z(&tsr, n, lens);
  LOG("\t- tsr = <%p>\n", (void *)tsr);

  tensor_lengths_z(tsr, n, _lenghts);
  LOG("\t- got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("\t- got name %s for <%p>\n", name, (void *)tsr);

  LOG("\t- Freeing <%p>\n", (void *)tsr);
  tensor_free_z(tsr);

  LOG("\n\n");
}
#+end_src
:end:


*** Simple contraction

#+begin_src c :tangle templates/test-simple-contraction.c 
#line 1 "simple-contraction-org-src"
{

  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_@FIELD_NAME@[0m functions\n",
      ++TEST_NUMBER);

  tensor_h A = 0x0, B = 0x0, C = 0x0;

  size_t
    lens_A[] = {20, 20, 30}, dim_A = 3,
    lens_B[] = {30, 20}, dim_B = 2,
    lens_C[] = {20}, dim_C = 1;

  @FIELD_CTYPE@
    alpha = { 1 },
    beta = { 0 };

  assert(A == 0x0); assert(B == 0x0); assert(C == 0x0);
  tensor_init_@FIELD_NAME@(&A, dim_A, lens_A);
  tensor_init_@FIELD_NAME@(&B, dim_B, lens_B);
  tensor_init_@FIELD_NAME@(&C, dim_C, lens_C);
  assert(A != 0x0); assert(B != 0x0); assert(C != 0x0);

  LOG("\t- Contracting C[a] = A[abc] * B[cb]\n");
  tensor_contract_@FIELD_NAME@(&alpha,
                               A,
                               "abc",
                               B,
                               "cb",
                               &beta,
                               "a",
                               C);

}
#+end_src

#+call: instantiate-template(in="test-simple-contraction.c", tangle="test.c", lang="c")

#+RESULTS:
:results:
#+begin_src c :tangle test.c
#line 1 "simple-contraction-org-src"
{

  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_s[0m functions\n",
      ++TEST_NUMBER);

  tensor_h A = 0x0, B = 0x0, C = 0x0;

  size_t
    lens_A[] = {20, 20, 30}, dim_A = 3,
    lens_B[] = {30, 20}, dim_B = 2,
    lens_C[] = {20}, dim_C = 1;

  float
    alpha = { 1 },
    beta = { 0 };

  assert(A == 0x0); assert(B == 0x0); assert(C == 0x0);
  tensor_init_s(&A, dim_A, lens_A);
  tensor_init_s(&B, dim_B, lens_B);
  tensor_init_s(&C, dim_C, lens_C);
  assert(A != 0x0); assert(B != 0x0); assert(C != 0x0);

  LOG("\t- Contracting C[a] = A[abc] * B[cb]\n");
  tensor_contract_s(&alpha,
                               A,
                               "abc",
                               B,
                               "cb",
                               &beta,
                               "a",
                               C);

}
#line 1 "simple-contraction-org-src"
{

  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_d[0m functions\n",
      ++TEST_NUMBER);

  tensor_h A = 0x0, B = 0x0, C = 0x0;

  size_t
    lens_A[] = {20, 20, 30}, dim_A = 3,
    lens_B[] = {30, 20}, dim_B = 2,
    lens_C[] = {20}, dim_C = 1;

  double
    alpha = { 1 },
    beta = { 0 };

  assert(A == 0x0); assert(B == 0x0); assert(C == 0x0);
  tensor_init_d(&A, dim_A, lens_A);
  tensor_init_d(&B, dim_B, lens_B);
  tensor_init_d(&C, dim_C, lens_C);
  assert(A != 0x0); assert(B != 0x0); assert(C != 0x0);

  LOG("\t- Contracting C[a] = A[abc] * B[cb]\n");
  tensor_contract_d(&alpha,
                               A,
                               "abc",
                               B,
                               "cb",
                               &beta,
                               "a",
                               C);

}
#line 1 "simple-contraction-org-src"
{

  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_c[0m functions\n",
      ++TEST_NUMBER);

  tensor_h A = 0x0, B = 0x0, C = 0x0;

  size_t
    lens_A[] = {20, 20, 30}, dim_A = 3,
    lens_B[] = {30, 20}, dim_B = 2,
    lens_C[] = {20}, dim_C = 1;

  _Complex float
    alpha = { 1 },
    beta = { 0 };

  assert(A == 0x0); assert(B == 0x0); assert(C == 0x0);
  tensor_init_c(&A, dim_A, lens_A);
  tensor_init_c(&B, dim_B, lens_B);
  tensor_init_c(&C, dim_C, lens_C);
  assert(A != 0x0); assert(B != 0x0); assert(C != 0x0);

  LOG("\t- Contracting C[a] = A[abc] * B[cb]\n");
  tensor_contract_c(&alpha,
                               A,
                               "abc",
                               B,
                               "cb",
                               &beta,
                               "a",
                               C);

}
#line 1 "simple-contraction-org-src"
{

  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_z[0m functions\n",
      ++TEST_NUMBER);

  tensor_h A = 0x0, B = 0x0, C = 0x0;

  size_t
    lens_A[] = {20, 20, 30}, dim_A = 3,
    lens_B[] = {30, 20}, dim_B = 2,
    lens_C[] = {20}, dim_C = 1;

  _Complex double
    alpha = { 1 },
    beta = { 0 };

  assert(A == 0x0); assert(B == 0x0); assert(C == 0x0);
  tensor_init_z(&A, dim_A, lens_A);
  tensor_init_z(&B, dim_B, lens_B);
  tensor_init_z(&C, dim_C, lens_C);
  assert(A != 0x0); assert(B != 0x0); assert(C != 0x0);

  LOG("\t- Contracting C[a] = A[abc] * B[cb]\n");
  tensor_contract_z(&alpha,
                               A,
                               "abc",
                               B,
                               "cb",
                               &beta,
                               "a",
                               C);

}
#+end_src
:end:

*** Epilog
#+begin_src c

  global_world_free();
  MPI_Finalize();
  return 0;
} // main
#+end_src


** Epilog
#+begin_src c++ :tangle teinst.h
#ifdef __cplusplus
} // extern "C"
#endif

#endif // _TEINST_H_DEFINED
#+end_src

#+begin_src c++ :tangle teinst.cxx
} // extern "C"
#+end_src
