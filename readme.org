* API
:PROPERTIES:
:header-args:c+++: :noweb yes :eval no
:header-args:lisp+: :eval no :noweb yes
:header-args:c+: :eval no
:header-args:org+: :eval no
:END:

** Scripts                                                         :noexport:

#+name: instantiate-template
#+begin_src shell :var in="" tangle="/tmp/test" lang="c++" :results verbatim drawer
echo "#+begin_src $lang :tangle $tangle"
./tools/field-instantiate.sh templates/$in
echo "#+end_src"
#+end_src

#+RESULTS: instantiate-template
:results:
#+begin_src c++ :tangle /tmp/test
#+end_src
:end:


#+name: instantiate-header
#+begin_src shell :var in="" tangle="/tmp/test" lang="c++" :results verbatim drawer
echo "#+begin_src $lang :tangle $tangle"
tmp=$(mktemp)
cp templates/${in} "${tmp}"
sed -i "s/)[ ]*$/);/g" ${tmp}
./tools/field-instantiate.sh ${tmp}
echo "#+end_src"
#+end_src

#+RESULTS: instantiate-header
:results:
#+begin_src c++ :tangle /tmp/test
#+end_src
:end:


** Prolog
#+begin_src c++ :tangle teinst.h
#ifndef _TEINST_H_DEFINED
#define _TEINST_H_DEFINED

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

#+end_src

#+begin_src c++ :tangle teinst.cxx
#include <backend/ctf.hpp>
#include <complex>
#include <iostream>
#include <string>
#include <teinst.h>

    extern "C" {

#+end_src

*** Lisp

#+begin_src lisp :tangle cffi.lisp
(in-package :teinst)

(define-foreign-library libteinst (t (:default "libteinst")))
(use-foreign-library libteinst)
#+end_src



** The tensor handle =tensor_h= type

#+begin_src c++ :tangle teinst.h
typedef size_t tensor_h;
#+end_src

*** Lisp

#+begin_src lisp :eval no :tangle cffi.lisp
(defctype tensor-h (:pointer :size))
#+end_src

** World functions

#+begin_src c++ :tangle teinst.h
void global_world_init();
void global_world_free();
#+end_src


#+begin_src c++ :tangle teinst.cxx
static CTF::World *TEINST_GLOBAL_WORLD = nullptr;

void global_world_init() {
  if (TEINST_GLOBAL_WORLD == nullptr) {
    TEINST_GLOBAL_WORLD = new CTF::World();
  }
}

void global_world_free() {
  if (TEINST_GLOBAL_WORLD != nullptr) {
    delete TEINST_GLOBAL_WORLD;
    TEINST_GLOBAL_WORLD = nullptr;
  }
}
#+end_src

#+begin_src lisp :tangle cffi.lisp
(defcfun ("global_world_init" %global-world-init) :void)
(defcfun ("global_world_free" %global-world-free) :void)
#+end_src


** =tensor_init=

#+name: tensor-init-doc
#+begin_src org
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind @FIELD_NAME@.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension.
#+end_src

#+begin_src c++ :noweb-ref tensor-init-header :tangle templates/tensor_init.h
// <<tensor-init-doc>>
void tensor_init_@FIELD_NAME@(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths)
#+end_src

#+begin_src c++ :tangle templates/tensor_init.cxx 
<<tensor-init-header>> {
  using F = @FIELD_TYPE@;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               ,*TEINST_GLOBAL_WORLD);
  ,*t = reinterpret_cast<tensor_h>(_t);
}
#+end_src

#+begin_src lisp :eval no :tangle templates/tensor_init.lisp 
(defcfun ("tensor_init_@FIELD_NAME@" %tensor-init-@FIELD_NAME@) :void
  "
<<tensor-init-doc>>"
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
#+end_src


*** Instantiation
**** Implementation

#+call: instantiate-template(in="tensor_init.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind s.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_s(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = float;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind d.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_d(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = double;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind c.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_c(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = std::complex<float>;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind z.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_z(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = std::complex<double>;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
#+end_src
:end:

**** Header

#+call: instantiate-header(in="tensor_init.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind s.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_s(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind d.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_d(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind c.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_c(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
// It will initialize the tensor handle =t= with the address of
// a valid backend tensor of kind z.
// =ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
// has 3 dimensions.
// =lengths= is an array with the size of every dimension.
void tensor_init_z(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_init.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_init_s" %tensor-init-s) :void
  "
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind s.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension."
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_d" %tensor-init-d) :void
  "
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind d.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension."
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_c" %tensor-init-c) :void
  "
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind c.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension."
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_z" %tensor-init-z) :void
  "
It will initialize the tensor handle =t= with the address of
a valid backend tensor of kind z.
=ndim= is the number of dimensions of the tensor, e.g. =t(a,b,c)=
has 3 dimensions.
=lengths= is an array with the size of every dimension."
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
#+end_src
:end:

** =tensor_lengths=

#+begin_src c++ :noweb-ref tensor-lengths-header :tangle templates/tensor_lengths.h
void tensor_lengths_@FIELD_NAME@(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths)
#+end_src

#+begin_src c++ :tangle templates/tensor_lengths.cxx 
<<tensor-lengths-header>> {
  using F = @FIELD_TYPE@;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }

#+end_src

#+begin_src lisp :eval no :tangle templates/tensor_lengths.lisp
(defcfun ("tensor_lengths_@FIELD_NAME@" %tensor-lengths-@FIELD_NAME@) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
#+end_src


*** Instantiation
**** Implementation
#+call: instantiate-template(in="tensor_lengths.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
void tensor_lengths_s(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths) {
  using F = float;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }
void tensor_lengths_d(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths) {
  using F = double;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }
void tensor_lengths_c(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths) {
  using F = std::complex<float>;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }
void tensor_lengths_z(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths) {
  using F = std::complex<double>;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  for (size_t i = 0; i < dimension; i++) {
    lengths[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
 }
#+end_src
:end:

**** Header
#+call: instantiate-header(in="tensor_lengths.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
void tensor_lengths_s(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths);
void tensor_lengths_d(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths);
void tensor_lengths_c(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths);
void tensor_lengths_z(const tensor_h t,
                                 size_t dimension,
                                 size_t* lengths);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_lengths.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_lengths_s" %tensor-lengths-s) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
(defcfun ("tensor_lengths_d" %tensor-lengths-d) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
(defcfun ("tensor_lengths_c" %tensor-lengths-c) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
(defcfun ("tensor_lengths_z" %tensor-lengths-z) :void
  (tsr tensor-h)
  (dimension :size)
  (lengths :pointer))
#+end_src
:end:

** =tensor_free=

#+begin_src c++ :noweb-ref tensor-free-header :tangle templates/tensor_free.h
void tensor_free_@FIELD_NAME@(tensor_h t)
#+end_src


#+begin_src c++ :tangle templates/tensor_free.cxx
<<tensor-free-header>> {
  using F = @FIELD_TYPE@;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
#+end_src

#+begin_src lisp :tangle templates/tensor_free.lisp
(defcfun ("tensor_free_@FIELD_NAME@" %tensor-free-@FIELD_NAME@) :void
  (tsr tensor-h))
#+end_src


*** Instantiation
**** Implementation

#+call: instantiate-template(in="tensor_free.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
void tensor_free_s(tensor_h t) {
  using F = float;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_d(tensor_h t) {
  using F = double;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_c(tensor_h t) {
  using F = std::complex<float>;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_z(tensor_h t) {
  using F = std::complex<double>;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
#+end_src
:end:

**** Header

#+call: instantiate-header(in="tensor_free.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
void tensor_free_s(tensor_h t);
void tensor_free_d(tensor_h t);
void tensor_free_c(tensor_h t);
void tensor_free_z(tensor_h t);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_free.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_free_s" %tensor-free-s) :void
  (tsr tensor-h))
(defcfun ("tensor_free_d" %tensor-free-d) :void
  (tsr tensor-h))
(defcfun ("tensor_free_c" %tensor-free-c) :void
  (tsr tensor-h))
(defcfun ("tensor_free_z" %tensor-free-z) :void
  (tsr tensor-h))
#+end_src
:end:

** =tensor_name=

#+begin_src c++ :noweb-ref tensor-name-header
void tensor_name(tensor_h t, char** nameptr)
#+end_src


#+begin_src c++ :tangle teinst.h
<<tensor-name-header>>;
#+end_src

#+begin_src c++ :tangle teinst.cxx
<<tensor-name-header>> {
    const std::string name =
        (reinterpret_cast<CTF::Tensor<double> *>(t))->get_name();
    *nameptr = (char *)malloc(name.size());
    memcpy(*nameptr, name.c_str(), name.size());
}
#+end_src

#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_name" %tensor-name) :void
  (tsr tensor-h)
  (name :pointer))
#+end_src


** Test
:PROPERTIES:
:header-args:c+: :tangle test.c
:END:

*** Prolog

#+begin_src c
#include <assert.h>
#include <mpi.h>
#include <stdio.h>
#include <teinst.h>

#define LOG(...) if (!rank) printf(__VA_ARGS__);

int main(int argc, char **argv) {
  MPI_Init(&argc, &argv);
  int rank, np;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &np);
  LOG("[31mTEINST TEST[0m (:np %d :rank %d)\n\n", np, rank);
  global_world_init();

  size_t TEST_NUMBER = 0;

#+end_src

*** Simple init

#+begin_src c :tangle templates/simple-init.c 
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_@FIELD_NAME@[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\ttsr = <%p>\n", (void *)tsr);
  tensor_init_@FIELD_NAME@(&tsr, n, lens);
  LOG("\ttsr = <%p>\n", (void *)tsr);

  tensor_lengths_@FIELD_NAME@(tsr, n, _lenghts);
  LOG("got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("got name %s for <%p>\n", name, (void *)tsr);

  LOG("Freeing <%p>\n", (void *)tsr);
  tensor_free_@FIELD_NAME@(tsr);

  LOG("\n\n");
}
#+end_src

#+call: instantiate-template(in="simple-init.c", tangle="test.c", lang="c")

#+RESULTS:
:results:
#+begin_src c :tangle test.c
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_s[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\ttsr = <%p>\n", (void *)tsr);
  tensor_init_s(&tsr, n, lens);
  LOG("\ttsr = <%p>\n", (void *)tsr);

  tensor_lengths_s(tsr, n, _lenghts);
  LOG("got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("got name %s for <%p>\n", name, (void *)tsr);

  LOG("Freeing <%p>\n", (void *)tsr);
  tensor_free_s(tsr);

  LOG("\n\n");
}
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_d[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\ttsr = <%p>\n", (void *)tsr);
  tensor_init_d(&tsr, n, lens);
  LOG("\ttsr = <%p>\n", (void *)tsr);

  tensor_lengths_d(tsr, n, _lenghts);
  LOG("got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("got name %s for <%p>\n", name, (void *)tsr);

  LOG("Freeing <%p>\n", (void *)tsr);
  tensor_free_d(tsr);

  LOG("\n\n");
}
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_c[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\ttsr = <%p>\n", (void *)tsr);
  tensor_init_c(&tsr, n, lens);
  LOG("\ttsr = <%p>\n", (void *)tsr);

  tensor_lengths_c(tsr, n, _lenghts);
  LOG("got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("got name %s for <%p>\n", name, (void *)tsr);

  LOG("Freeing <%p>\n", (void *)tsr);
  tensor_free_c(tsr);

  LOG("\n\n");
}
{
  LOG("%ld) Running [36m'Simple Test'[0m for [33m*_z[0m functions\n",
      ++TEST_NUMBER);

  size_t n = 4;
  size_t _lenghts[4];
  size_t lens[] = {1UL + TEST_NUMBER,
                   2UL + TEST_NUMBER,
                   3UL + TEST_NUMBER,
                   4UL + TEST_NUMBER};
  char *name;
  tensor_h tsr;

  LOG("\ttsr = <%p>\n", (void *)tsr);
  tensor_init_z(&tsr, n, lens);
  LOG("\ttsr = <%p>\n", (void *)tsr);

  tensor_lengths_z(tsr, n, _lenghts);
  LOG("got lengths = {%ld %ld %ld %ld}\n", /**/
      _lenghts[0], _lenghts[1],
      _lenghts[2], _lenghts[3]);
  size_t i = 0;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]); i++;
  assert(lens[i] == _lenghts[i]);

  tensor_name(tsr, &name);
  LOG("got name %s for <%p>\n", name, (void *)tsr);

  LOG("Freeing <%p>\n", (void *)tsr);
  tensor_free_z(tsr);

  LOG("\n\n");
}
#+end_src
:end:


*** Epilog
#+begin_src c

  global_world_free();
  MPI_Finalize();
  return 0;
} // main
#+end_src


** Epilog
#+begin_src c++ :tangle teinst.h
#ifdef __cplusplus
} // extern "C"
#endif

#endif // _TEINST_H_DEFINED
#+end_src

#+begin_src c++ :tangle teinst.cxx
} // extern "C"
#+end_src
