* API
:PROPERTIES:
:header-args:c++: :noweb yes :eval no
:header-args:lisp: :eval no
:END:

** Scripts                                                         :noexport:

#+name: instantiate-template
#+begin_src shell :var in="" tangle="/tmp/test" lang="c++" :results verbatim drawer
echo "#+begin_src $lang :tangle $tangle"
./tools/field-instantiate.sh templates/$in
echo "#+end_src"
#+end_src

#+RESULTS: instantiate-template
:results:
#+begin_src c++ :tangle /tmp/test
#+end_src
:end:


#+name: instantiate-header
#+begin_src shell :var in="" tangle="/tmp/test" lang="c++" :results verbatim drawer
echo "#+begin_src $lang :tangle $tangle"
tmp=$(mktemp)
cp templates/${in} "${tmp}"
sed -i "s/)[ ]*$/);/g" ${tmp}
./tools/field-instantiate.sh ${tmp}
echo "#+end_src"
#+end_src

#+RESULTS: instantiate-header
:results:
#+begin_src c++ :tangle /tmp/test
#+end_src
:end:


** Prolog
#+begin_src c++ :tangle teinst.h
#ifndef _TEINST_H_DEFINED
#define _TEINST_H_DEFINED

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

#+end_src

#+begin_src c++ :tangle teinst.cxx
#include <backend/ctf.hpp>
#include <complex>
#include <iostream>
#include <string>
#include <teinst.h>

    extern "C" {

#+end_src


** The tensor handle =tensor_h= type

#+begin_src c++ :tangle teinst.h
typedef size_t tensor_h;
#+end_src

** Lisp

#+begin_src lisp :eval no :tangle cffi.lisp
(defctype tensor-h (:pointer :size))
#+end_src

** World functions

#+begin_src c++ :tangle teinst.h
void global_world_init();
void global_world_free();
#+end_src


#+begin_src c++ :tangle teinst.cxx
static CTF::World *TEINST_GLOBAL_WORLD = nullptr;

void global_world_init() {
  if (TEINST_GLOBAL_WORLD == nullptr) {
    TEINST_GLOBAL_WORLD = new CTF::World();
  }
}

void global_world_free() {
  std::cout << "freeing world\n";
  if (TEINST_GLOBAL_WORLD != nullptr) {
    delete TEINST_GLOBAL_WORLD;
    TEINST_GLOBAL_WORLD = nullptr;
  }
}
#+end_src

** =tensor_init=

#+begin_src c++ :noweb-ref tensor-init-header :tangle templates/tensor_init.h
void tensor_init_@FIELD_NAME@(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths)
#+end_src

#+begin_src c++ :tangle templates/tensor_init.cxx 
<<tensor-init-header>> {
  using F = @FIELD_TYPE@;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               ,*TEINST_GLOBAL_WORLD);
  ,*t = reinterpret_cast<tensor_h>(_t);
}
#+end_src

#+begin_src lisp :eval no :tangle templates/tensor_init.lisp 
(defcfun ("tensor_init_@FIELD_NAME@" %tensor-init-@FIELD_NAME@)
    :void
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
#+end_src


*** Instantiation
**** Implementation

#+call: instantiate-template(in="tensor_init.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
void tensor_init_s(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = float;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
void tensor_init_d(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = double;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
void tensor_init_c(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = std::complex<float>;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
void tensor_init_z(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths) {
  using F = std::complex<double>;
  global_world_init();
  std::vector<int> syms(ndim, NS), lens(ndim);
  for (size_t i = 0; i < ndim; i++) {
    lens[i] = lengths[i];
  }
  auto _t = new CTF::Tensor<F>((int)ndim, lens.data(), syms.data(),
                               *TEINST_GLOBAL_WORLD);
  *t = reinterpret_cast<tensor_h>(_t);
}
#+end_src
:end:

**** Header

#+call: instantiate-header(in="tensor_init.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
void tensor_init_s(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
void tensor_init_d(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
void tensor_init_c(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
void tensor_init_z(tensor_h* t,
                    const size_t ndim,
                    const size_t* lengths);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_init.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_init_s" %tensor-init-s)
    :void
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_d" %tensor-init-d)
    :void
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_c" %tensor-init-c)
    :void
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
(defcfun ("tensor_init_z" %tensor-init-z)
    :void
  (tsr (:pointer tensor-h))
  (ndim :size)
  (lengths (:pointer :size)))
#+end_src
:end:

** =tensor_lengths=

#+begin_src c++ :noweb-ref tensor-lengths-header :tangle templates/tensor_lengths.h
void tensor_lengths_@FIELD_NAME@(const tensor_h t,
                               size_t** lengths)
#+end_src

#+begin_src c++ :tangle templates/tensor_lengths.cxx 
<<tensor-lengths-header>> {
  using F = @FIELD_TYPE@;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  size_t * _v = (size_t*)malloc(sizeof(size_t) * _t->order);
  for (size_t i = 0; i < (size_t)_t->order; i++) {
    _v[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
  ,*lengths = _v;
 }

#+end_src

#+begin_src lisp :eval no :tangle templates/tensor_lengths.lisp
(defcfun ("tensor_lengths_@FIELD_NAME@" %tensor-lengths-@FIELD_NAME@) :void
  (tsr tensor-h)
  (lengths :pointer))
#+end_src


*** Instantiation
**** Implementation
#+call: instantiate-template(in="tensor_lengths.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
void tensor_lengths_s(const tensor_h t,
                               size_t** lengths) {
  using F = float;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  size_t * _v = (size_t*)malloc(sizeof(size_t) * _t->order);
  for (size_t i = 0; i < (size_t)_t->order; i++) {
    _v[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
  *lengths = _v;
 }
void tensor_lengths_d(const tensor_h t,
                               size_t** lengths) {
  using F = double;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  size_t * _v = (size_t*)malloc(sizeof(size_t) * _t->order);
  for (size_t i = 0; i < (size_t)_t->order; i++) {
    _v[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
  *lengths = _v;
 }
void tensor_lengths_c(const tensor_h t,
                               size_t** lengths) {
  using F = std::complex<float>;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  size_t * _v = (size_t*)malloc(sizeof(size_t) * _t->order);
  for (size_t i = 0; i < (size_t)_t->order; i++) {
    _v[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
  *lengths = _v;
 }
void tensor_lengths_z(const tensor_h t,
                               size_t** lengths) {
  using F = std::complex<double>;
  auto const _t = reinterpret_cast<CTF::Tensor<F>*>(t);
  size_t * _v = (size_t*)malloc(sizeof(size_t) * _t->order);
  for (size_t i = 0; i < (size_t)_t->order; i++) {
    _v[i] = reinterpret_cast<int64_t>(_t->lens[i]);
  }
  *lengths = _v;
 }
#+end_src
:end:

**** Header
#+call: instantiate-header(in="tensor_lengths.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
void tensor_lengths_s(const tensor_h t,
                               size_t** lengths);
void tensor_lengths_d(const tensor_h t,
                               size_t** lengths);
void tensor_lengths_c(const tensor_h t,
                               size_t** lengths);
void tensor_lengths_z(const tensor_h t,
                               size_t** lengths);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_lengths.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_lengths_s" %tensor-lengths-s) :void
  (tsr tensor-h)
  (lengths :pointer))
(defcfun ("tensor_lengths_d" %tensor-lengths-d) :void
  (tsr tensor-h)
  (lengths :pointer))
(defcfun ("tensor_lengths_c" %tensor-lengths-c) :void
  (tsr tensor-h)
  (lengths :pointer))
(defcfun ("tensor_lengths_z" %tensor-lengths-z) :void
  (tsr tensor-h)
  (lengths :pointer))
#+end_src
:end:

** =tensor_free=

#+begin_src c++ :noweb-ref tensor-free-header :tangle templates/tensor_free.h
void tensor_free_@FIELD_NAME@(tensor_h t)
#+end_src


#+begin_src c++ :tangle templates/tensor_free.cxx
<<tensor-free-header>> {
  using F = @FIELD_TYPE@;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
#+end_src

#+begin_src lisp :tangle templates/tensor_free.lisp
(defcfun ("tensor_free_@FIELD_NAME@" %tensor-free-@FIELD_NAME@) :void
  (tsr tensor-h))
#+end_src


*** Instantiation
**** Implementation

#+call: instantiate-template(in="tensor_free.cxx", tangle="teinst.cxx")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.cxx
void tensor_free_s(tensor_h t) {
  using F = float;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_d(tensor_h t) {
  using F = double;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_c(tensor_h t) {
  using F = std::complex<float>;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
void tensor_free_z(tensor_h t) {
  using F = std::complex<double>;
  delete reinterpret_cast<CTF::Tensor<F> *>(t);
 }
#+end_src
:end:

**** Header

#+call: instantiate-header(in="tensor_free.h", tangle="teinst.h")

#+RESULTS:
:results:
#+begin_src c++ :tangle teinst.h
void tensor_free_s(tensor_h t);
void tensor_free_d(tensor_h t);
void tensor_free_c(tensor_h t);
void tensor_free_z(tensor_h t);
#+end_src
:end:

**** Lisp

#+call: instantiate-template(in="tensor_free.lisp", tangle="cffi.lisp", lang="lisp")

#+RESULTS:
:results:
#+begin_src lisp :tangle cffi.lisp
(defcfun ("tensor_free_s" %tensor-free-s) :void
  (tsr tensor-h))
(defcfun ("tensor_free_d" %tensor-free-d) :void
  (tsr tensor-h))
(defcfun ("tensor_free_c" %tensor-free-c) :void
  (tsr tensor-h))
(defcfun ("tensor_free_z" %tensor-free-z) :void
  (tsr tensor-h))
#+end_src
:end:

** =tensor_name=

#+begin_src c++ :noweb-ref tensor-name-header
void tensor_name(tensor_h t, char** nameptr)
#+end_src


#+begin_src c++ :tangle teinst.h
<<tensor-name-header>>;
#+end_src

#+begin_src c++ :tangle teinst.cxx
<<tensor-name-header>> {
    const std::string name =
        (reinterpret_cast<CTF::Tensor<double> *>(t))->get_name();
    std::cout << name << std::endl;
    *nameptr = (char *)malloc(name.size());
    memcpy(*nameptr, name.c_str(), name.size());
}
#+end_src

** Epilog
#+begin_src c++ :tangle teinst.h
#ifdef __cplusplus
} // extern "C"
#endif

#endif // _TEINST_H_DEFINED
#+end_src

#+begin_src c++ :tangle teinst.cxx
} // extern "C"
#+end_src
